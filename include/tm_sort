#ifndef __$__TM_CPP_SORT_ALGORITHM__2025_
#define __$__TM_CPP_SORT_ALGORITHM__2025_

#include<tm_algorithm>
#include<stack>
#include<vector>
#include<iterator>
namespace algo
{
template<typename RandomIter, typename Compare>
void bubble_sort(RandomIter begin, RandomIter end,Compare cmp)
{
RandomIter y,e,f;
for(y=end-1;y>begin;y--) for(e=begin,f=e+1;e<y;e++,f++) if(cmp(*e,*f)>0) algo::iter_swap(e,f);
}

template<typename RandomIter,typename Compare>
void linear_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f;
for(e=begin;e<end-1;e++) for(f=e;f<end;f++) if(cmp(*e,*f)>0) algo::iter_swap(e,f);
}


template<typename RandomIter, typename Compare>
void selection_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f,m;
for(e=begin;e<end-1;e++) 
{
m=e;
for(f=e;f<end;f++) if(cmp(*m,*f)>0) m=f;
algo::iter_swap(m,e);
}
}

template<typename RandomIter,typename Compare>
void insertion_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter y,j;
for(y=begin+1;y<end;y++)
{
typename std::iterator_traits<RandomIter>::value_type data=*y;
for(j=y-1;j>=begin && cmp(*j,data)>0;j--) *(j+1)=*j;
*(j+1)=data;
}
}

template<typename RandomIter,typename Compare>
RandomIter partition_point(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f;
e=begin;
f=end;
while(e<f)
{
while(e<=end && cmp(*e,*begin)<=0) e++;
while(cmp(*f,*begin)>0) f--;
if(e<f) algo::iter_swap(e,f);
else algo::iter_swap(begin,f);
}
return f;
}

template<typename RandomIter,typename Compare>
void _quick_sort_iterative(RandomIter begin, RandomIter end,Compare cmp)
{
struct pair
{
RandomIter begin;
RandomIter end;
};
std::stack<pair*> pair_stack;
RandomIter pp;
pair *p1,*p2;
p1=new pair();
p1->begin=begin;
p1->end=end;
pair_stack.push(p1);
while(!pair_stack.empty())
{
p1=pair_stack.top();
pair_stack.pop();
pp=partition_point(p1->begin,p1->end,cmp);
if(p1->begin < pp-1)
{
p2=new pair();
p2->begin=begin;
p2->end=pp-1;
pair_stack.push(p2);
}
if(pp+1 < end)
{
p2=new pair();
p2->begin=pp+1;
p2->end=end;
pair_stack.push(p2);
}
delete p1;
}
}

template<typename RandomIter,typename Compare>
void quick_sort_iterative(RandomIter begin, RandomIter end,Compare cmp)
{
_quick_sort_iterative(begin,end-1,cmp);
}

template<typename RandomIter,typename Compare>
void _quick_sort(RandomIter begin, RandomIter end,Compare cmp)
{
if(begin>=end) return;
RandomIter pp=partition_point(begin,end,cmp);
_quick_sort(begin,pp-1,cmp);
_quick_sort(pp+1,end,cmp);
}

template<typename RandomIter,typename Compare>
void quick_sort(RandomIter begin, RandomIter end,Compare cmp)
{
_quick_sort(begin,end-1,cmp);
}

template<class RandomIter, class Compare>
void merge(RandomIter begin,RandomIter end,Compare cmp)
{
typename std::iterator_traits<RandomIter>::difference_type size=algo::count(begin,end);
typename std::iterator_traits<RandomIter>::difference_type mid=size/2;
RandomIter l1,l2,l3;
std::vector<typename std::iterator_traits<RandomIter>::value_type> buffer;
l1=begin;
l2=begin+mid;
l3=l2+1;
while(l1<=l2 && l3<=end)
{
if(cmp(*l1,*l3)<0)
{
buffer.push_back(*l1);
l1++;
}
else
{
buffer.push_back(*l3);
l3++;
}
}
while(l1<=l2)
{
buffer.push_back(*l1);
l1++;
}
while(l3<=end)
{
buffer.push_back(*l3);
l3++;
}
for(auto a:buffer)
{
*begin=a;
begin++;
}
}

template<typename RandomIter, typename Compare>
void _merge_sort(RandomIter begin, RandomIter end,Compare cmp)
{
if(begin>=end) return;
auto size=algo::count(begin,end);
auto mid=size/2;
_merge_sort(begin,begin+mid,cmp);
_merge_sort(begin+mid+1,end,cmp);
merge(begin,end,cmp);
}

template<typename RandomIter, typename Compare>
void merge_sort(RandomIter begin, RandomIter end,Compare cmp)
{
_merge_sort(begin,end-1,cmp);
}

template<typename RandomIter, typename Compare>
void _merge_sort_iterative(RandomIter begin, RandomIter end, Compare cmp)
{
std::pair<RandomIter,RandomIter> p1;
std::stack<std::pair<RandomIter,RandomIter>> s1,s2;
s1.push(std::pair<RandomIter,RandomIter>(begin,end));
while(!s1.empty())
{
p1=s1.top();
s1.pop();
s2.push(p1);
auto size=algo::count(p1.first,p1.second);
auto mid=size/2;
if(p1.first < (p1.first+mid)) s1.push(std::pair<RandomIter,RandomIter>(p1.first,p1.first+mid));
if((p1.first+mid+1)<end) s1.push(std::pair<RandomIter,RandomIter>(p1.first+mid+1,p1.second));
}
while(!s2.empty())
{
p1=s2.top();
s2.pop();
merge(p1.first,p1.end,cmp);
}
}

template<typename RandomIter, typename Compare>
void merg_sort_iterative(RandomIter begin, RandomIter end, Compare cmp)
{
_merge_sort_iterative(begin,end-1,cmp);
}

template<typename ContiguousIter>
constexpr bool is_contiguous_iter(ContiguousIter c_iter)
{
if constexpr(std::random_access_iterator<ContiguousIter>) return true;
else return false;
}

template<typename RandomIter,typename Compare>
void heap_sort(RandomIter begin, RandomIter end,int fromIndex,int toIndex,Compare cmp)
{
if(fromIndex<0|| toIndex<0 || fromIndex>=toIndex) return;
int size=algo::count(begin,end);
if(fromIndex>size || toIndex>size) return;
int ri,ci,lci,rci,swi;
RandomIter ri_itr,ci_itr,lci_itr,rci_itr,swi_itr;
if(!is_contiguous_iter(begin)) return;
int i;
for(i=fromIndex;i<toIndex;i++)
{
ci=i+1;
while(ci>fromIndex)
{
ri=(ci-fromIndex-1)/2+fromIndex;
ri_itr=begin+ri;
ci_itr=begin+ci;
if(cmp(*ri_itr,*ci_itr)<0) 
{
algo::iter_swap(ri_itr,ci_itr);
ci=ri;
}
else break;
}
}
for(;toIndex>fromIndex;)
{
ri_itr=begin+fromIndex;
ci_itr=begin+toIndex;
algo::iter_swap(ri_itr,ci_itr);
toIndex--;
ri=fromIndex;
while(ri<toIndex)
{
lci=((ri*2)+1)-fromIndex;
if(lci>toIndex) break;
rci=lci+1;
if(rci>toIndex) swi=lci;
else
{
lci_itr=begin+lci;
rci_itr=begin+rci;
if(cmp(*lci_itr,*rci_itr)>0) swi=lci;
else swi=rci;
}
ri_itr=begin+ri;
swi_itr=begin+swi;
if(cmp(*ri_itr,*swi_itr)<0)
{
algo::iter_swap(ri_itr,swi_itr);
ri=swi;
}
else break;
}
}
}
}

#endif
