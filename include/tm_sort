#ifndef __$__TM_CPP_SORT_ALGORITHM__2025_
#define __$__TM_CPP_SORT_ALGORITHM__2025_

#include<tm_algorithm>
#include<stack>
#include<vector>
#include<iterator>
#include<forward_list>
namespace algo
{
template<typename RandomIter, typename Compare>
void bubble_sort(RandomIter begin, RandomIter end,Compare cmp)
{
RandomIter y,e,f;
for(y=end-1;y>begin;y--) for(e=begin,f=e+1;e<y;e++,f++) if(cmp(*e,*f)>0) algo::iter_swap(e,f);
}

template<typename RandomIter,typename Compare>
void linear_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f;
for(e=begin;e<end-1;e++) for(f=e;f<end;f++) if(cmp(*e,*f)>0) algo::iter_swap(e,f);
}


template<typename RandomIter, typename Compare>
void selection_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f,m;
for(e=begin;e<end-1;e++) 
{
m=e;
for(f=e;f<end;f++) if(cmp(*m,*f)>0) m=f;
algo::iter_swap(m,e);
}
}

template<typename RandomIter,typename Compare>
void insertion_sort(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter y,j;
for(y=begin+1;y<end;y++)
{
typename std::iterator_traits<RandomIter>::value_type data=*y;
for(j=y-1;j>=begin && cmp(*j,data)>0;j--) *(j+1)=*j;
*(j+1)=data;
}
}

template<typename RandomIter,typename Compare>
void shell_sort(RandomIter begin,RandomIter end, Compare cmp)
{
RandomIter y;
RandomIter j;
typename std::iterator_traits<RandomIter>::difference_type size=algo::count(begin,end);
typename std::iterator_traits<RandomIter>::difference_type diff=size/2;
while(diff>0)
{
for(y=begin+diff;y<end;y+=diff)
{
typename std::iterator_traits<RandomIter>::value_type num=*y;
for(j=y-diff;j>=begin && cmp(*j,num)>0;j-=diff) *(j+diff)=*j;
*(j+diff)=num;
}
diff/=2;
}
}


template<typename RandomIter,typename Compare>
RandomIter partition_point(RandomIter begin,RandomIter end,Compare cmp)
{
RandomIter e,f;
e=begin;
f=end;
while(e<f)
{
while(e<=end && cmp(*e,*begin)<=0) e++;
while(cmp(*f,*begin)>0) f--;
if(e<f) algo::iter_swap(e,f);
else algo::iter_swap(begin,f);
}
return f;
}

template<typename RandomIter,typename Compare>
void _quick_sort_iterative(RandomIter begin, RandomIter end,Compare cmp)
{
struct pair
{
RandomIter begin;
RandomIter end;
};
std::stack<pair*> pair_stack;
RandomIter pp;
pair *p1,*p2;
p1=new pair();
p1->begin=begin;
p1->end=end;
pair_stack.push(p1);
while(!pair_stack.empty())
{
p1=pair_stack.top();
pair_stack.pop();
pp=partition_point(p1->begin,p1->end,cmp);
if(p1->begin < pp-1)
{
p2=new pair();
p2->begin=begin;
p2->end=pp-1;
pair_stack.push(p2);
}
if(pp+1 < end)
{
p2=new pair();
p2->begin=pp+1;
p2->end=end;
pair_stack.push(p2);
}
delete p1;
}
}

template<typename RandomIter,typename Compare>
void quick_sort_iterative(RandomIter begin, RandomIter end,Compare cmp)
{
_quick_sort_iterative(begin,end-1,cmp);
}

template<typename RandomIter,typename Compare>
void _quick_sort(RandomIter begin, RandomIter end,Compare cmp)
{
if(begin>=end) return;
RandomIter pp=partition_point(begin,end,cmp);
_quick_sort(begin,pp-1,cmp);
_quick_sort(pp+1,end,cmp);
}

template<typename RandomIter,typename Compare>
void quick_sort(RandomIter begin, RandomIter end,Compare cmp)
{
_quick_sort(begin,end-1,cmp);
}

template<class RandomIter, class Compare>
void merge(RandomIter begin, RandomIter mid, RandomIter next_mid,RandomIter end,Compare cmp)
{
std::vector<typename std::iterator_traits<RandomIter>::value_type> buffer;
RandomIter l1,l2,l3;
l1=begin;
l2=mid;
l3=next_mid;
while(l1<=l2 && l3<=end)
{
if(cmp(*l1,*l3)<0)
{
buffer.push_back(*l1);
l1++;
}
else
{
buffer.push_back(*l3);
l3++;
}
}
while(l1<=l2)
{
buffer.push_back(*l1);
l1++;
}
while(l3<=end)
{
buffer.push_back(*l3);
l3++;
}
for(auto a:buffer)
{
*begin=a;
begin++;
}
}

template<class RandomIter, class Compare>
void merge(RandomIter begin,RandomIter end,Compare cmp)
{
typename std::iterator_traits<RandomIter>::difference_type size=algo::count(begin,end);
typename std::iterator_traits<RandomIter>::difference_type mid=size/2;
RandomIter l1,l2,l3;
std::vector<typename std::iterator_traits<RandomIter>::value_type> buffer;
l1=begin;
l2=begin+mid;
l3=l2+1;
while(l1<=l2 && l3<=end)
{
if(cmp(*l1,*l3)<0)
{
buffer.push_back(*l1);
l1++;
}
else
{
buffer.push_back(*l3);
l3++;
}
}
while(l1<=l2)
{
buffer.push_back(*l1);
l1++;
}
while(l3<=end)
{
buffer.push_back(*l3);
l3++;
}
for(auto a:buffer)
{
*begin=a;
begin++;
}
}

template<typename RandomIter, typename Compare>
void _merge_sort(RandomIter begin, RandomIter end,Compare cmp)
{
if(begin>=end) return;
auto size=algo::count(begin,end);
auto mid=size/2;
_merge_sort(begin,begin+mid,cmp);
_merge_sort(begin+mid+1,end,cmp);
merge(begin,end,cmp);
}

template<typename RandomIter, typename Compare>
void merge_sort(RandomIter begin, RandomIter end,Compare cmp)
{
_merge_sort(begin,end-1,cmp);
}

template<typename RandomIter, typename Compare>
void _merge_sort_iterative(RandomIter begin, RandomIter end, Compare cmp)
{
std::pair<RandomIter,RandomIter> p1;
std::stack<std::pair<RandomIter,RandomIter>> s1,s2;
s1.push(std::pair<RandomIter,RandomIter>(begin,end));
while(!s1.empty())
{
p1=s1.top();
s1.pop();
s2.push(p1);
auto size=algo::count(p1.first,p1.second);
auto mid=size/2;
if(p1.first < (p1.first+mid)) s1.push(std::pair<RandomIter,RandomIter>(p1.first,p1.first+mid));
if((p1.first+mid+1)<end) s1.push(std::pair<RandomIter,RandomIter>(p1.first+mid+1,p1.second));
}
while(!s2.empty())
{
p1=s2.top();
s2.pop();
merge(p1.first,p1.end,cmp);
}
}

template<typename RandomIter, typename Compare>
void merg_sort_iterative(RandomIter begin, RandomIter end, Compare cmp)
{
_merge_sort_iterative(begin,end-1,cmp);
}

template<typename ContiguousIter>
constexpr bool is_contiguous_iter(ContiguousIter c_iter)
{
if constexpr(std::random_access_iterator<ContiguousIter>) return true;
else return false;
}

template<typename RandomIter,typename Compare>
void heap_sort(RandomIter begin, RandomIter end,int fromIndex,int toIndex,Compare cmp)
{
if(fromIndex<0|| toIndex<0 || fromIndex>=toIndex) return;
int size=algo::count(begin,end);
if(fromIndex>size || toIndex>size) return;
int ri,ci,lci,rci,swi;
RandomIter ri_itr,ci_itr,lci_itr,rci_itr,swi_itr;
if(!is_contiguous_iter(begin)) return;
int i;
for(i=fromIndex;i<toIndex;i++)
{
ci=i+1;
while(ci>fromIndex)
{
ri=(ci-fromIndex-1)/2+fromIndex;
ri_itr=begin+ri;
ci_itr=begin+ci;
if(cmp(*ri_itr,*ci_itr)<0) 
{
algo::iter_swap(ri_itr,ci_itr);
ci=ri;
}
else break;
}
}
for(;toIndex>fromIndex;)
{
ri_itr=begin+fromIndex;
ci_itr=begin+toIndex;
algo::iter_swap(ri_itr,ci_itr);
toIndex--;
ri=fromIndex;
while(ri<toIndex)
{
lci=((ri*2)+1)-fromIndex;
if(lci>toIndex) break;
rci=lci+1;
if(rci>toIndex) swi=lci;
else
{
lci_itr=begin+lci;
rci_itr=begin+rci;
if(cmp(*lci_itr,*rci_itr)>0) swi=lci;
else swi=rci;
}
ri_itr=begin+ri;
swi_itr=begin+swi;
if(cmp(*ri_itr,*swi_itr)<0)
{
algo::iter_swap(ri_itr,swi_itr);
ri=swi;
}
else break;
}
}
}

template<typename RandomIter,typename Compare>
void pancake_sort(RandomIter begin, RandomIter end, Compare cmp)
{
RandomIter max_iter,i,y;
y=end-1;
while(y>begin)
{
max_iter=begin;
i=begin+1;
while(i<=y)
{
if(cmp(*max_iter,*i)<0) max_iter=i;
++i;
}
algo::reverse(begin,max_iter);
algo::reverse(begin,y);
y--;
}
}

template<typename RandomIter>
void count_sort(RandomIter begin, RandomIter end)
{
int max;
int num;
max=*begin;
std::vector<std::forward_list<typename std::iterator_traits<RandomIter>::value_type>*> *buffer;
for(RandomIter itr=begin+1;itr!=end;++itr) if(max<*itr) max=*itr;
max++;
buffer=new std::vector<std::forward_list<typename std::iterator_traits<RandomIter>::value_type>*>(max,nullptr);
for(RandomIter itr=begin;itr!=end;++itr)
{
num=*itr;
auto b=buffer->at(num);
if(b==nullptr) b=new std::forward_list<typename std::iterator_traits<RandomIter>::value_type>;
b->push_front(*itr);
buffer->at(num)=b;
}
RandomIter ri=begin;
for(int i=0;i<max;i++)
{
auto v=buffer->at(i);
if(v)
{
for(typename std::forward_list<typename std::iterator_traits<RandomIter>::value_type>::iterator itr=v->begin();itr!=v->end();++itr)
{
*ri=*itr;
++ri;
}
delete v;
}
}
delete(buffer);
}

template<typename RandomIter,class Compare>
void bucket_sort(RandomIter begin, RandomIter end,Compare cmp)
{
RandomIter max;
RandomIter itr;
int dc;
int idx;
int num;
std::array<std::forward_list<typename std::iterator_traits<RandomIter>::value_type> *,10> buffer;
for(int j=0;j<=9;j++) buffer[j]=NULL;
typename std::forward_list<typename std::iterator_traits<RandomIter>::value_type>::iterator prev;
typename std::forward_list<typename std::iterator_traits<RandomIter>::value_type>::iterator i;
std::forward_list<typename std::iterator_traits<RandomIter>::value_type> *fl_itr=NULL;
max=begin;
for(RandomIter y=begin+1;y<end;y++) if(cmp(*max,*y)<0) max=y;
for(dc=1,num=*max;num>9;dc*=10,num/=10);
itr=begin;
while(itr!=end)
{
num=*itr;
idx=num/dc;
if(buffer[idx])
{
fl_itr=buffer[idx];
for(prev=fl_itr->before_begin(),i=fl_itr->begin();i!=fl_itr->end();++i)
{
int right=*i;
if(cmp(num,right)<0) break;
prev=i;
}
fl_itr->insert_after(prev,*itr);
}
else
{
buffer[idx]=new std::forward_list<typename std::iterator_traits<RandomIter>::value_type>;
(buffer[idx])->push_front(*itr);
}
++itr;
}
itr=begin;
for(int j=0;j<=9;j++)
{
if(buffer[j])
{
for(i=buffer[j]->begin();i!=buffer[j]->end();++i)
{
*itr=*i;
++itr;
}
delete buffer[j];
}
}
}

template<typename RandomIter, typename Compare>
void gnom_sort(RandomIter begin, RandomIter end, Compare cmp)
{
RandomIter j;
j=begin;
while(j<end)
{
if(j==begin) j++;
if(j>begin && cmp(*j,*(j-1))<0)
{
algo::iter_swap(j,j-1);
j--;
}
else j++;
}
}

template<typename RandomIter, typename Compare>
void brick_sort(RandomIter begin, RandomIter end, Compare cmp)
{
if(algo::count(begin,end)==0) return;
RandomIter tmp;
bool isSwapped=true;
RandomIter _end=end-3;
RandomIter __end=end-2;
while(isSwapped)
{
if(isSwapped) isSwapped=false;
tmp=begin+1;
while(tmp<=_end)
{
if(cmp(*(tmp+1),*tmp)<0)
{
algo::iter_swap(tmp,tmp+1);
isSwapped=true;
}
tmp=tmp+2;
}
tmp=begin;
while(tmp<=__end)
{
if(cmp(*(tmp+1),*tmp)<0)
{
algo::iter_swap(tmp,tmp+1);
isSwapped=true;
}
tmp=tmp+2;
}
}
}

template<typename RandomIter>
void pigeon_hole_sort(RandomIter begin, RandomIter end)
{
std::vector<std::vector<typename std::iterator_traits<RandomIter>::value_type>> *buffer;
typename std::vector<std::vector<typename std::iterator_traits<RandomIter>::value_type>>::iterator buf_itr;
int max,min,index;
long int range;
max=0;
min=0;
for(RandomIter itr=begin;itr!=end;itr++)
{
if(max<*itr) max=*itr;
if(min>*itr) min=*itr;
}
range=(max-min)+1;
buffer=new std::vector<std::vector<typename std::iterator_traits<RandomIter>::value_type>>(range);
buf_itr=buffer->begin();
for(RandomIter itr=begin;itr!=end;itr++)
{
index=(*itr)-min;
buffer->at(index).push_back(*itr);
}
for(auto list : *buffer)
{
if(!list.empty())
{
for(auto l:list) 
{
*begin=l;
begin++;
}
}
}
delete buffer;
}

template<typename RandomIter, typename Compare>
void tim_sort(RandomIter begin, RandomIter end, Compare cmp)
{
int batch=10;
typename std::iterator_traits<RandomIter>::difference_type size=algo::count(begin,end);
if(size<=batch)
{
insertion_sort(begin,end,cmp);
return;
}
typename std::iterator_traits<RandomIter>::difference_type len;
int count=0;
if(size<batch) count=1;
else
{
count=size/batch;
if(size%batch!=0) count++;
}
RandomIter e,f;
e=begin;
f=begin+batch;
for(int i=1;i<=count;i++)
{
insertion_sort(e,f,cmp);
e=f;
len=algo::count(f,end);
if(len<batch) f=end;
else f=e+batch;
}
e=begin;
f=begin+batch-1;
RandomIter e2,f2;
for(int i=2;i<=count;i++)
{
len=algo::count(f+1,end);
if(len<batch) f2=end-1;
else f2=f+batch-1;
e2=f+1;
merge(e,f,e2,f2,cmp);
f=f2;
}
}
}

#endif
